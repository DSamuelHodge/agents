import type { WorkflowRun } from '../utils/types';

export interface ProjectStructure {
  [path: string]: string; // path -> file content
}

/**
 * Extract code blocks from markdown text
 * Handles ```language code blocks
 */
export function extractCode(
  text: string,
  language?: string
): { code: string; language: string }[] {
  const codeBlocks: { code: string; language: string }[] = [];
  const regex = /```(\w*)\n([\s\S]*?)```/g;
  let match;

  while ((match = regex.exec(text)) !== null) {
    const [, lang, code] = match;
    if (!language || lang === language) {
      codeBlocks.push({
        code: code.trim(),
        language: lang || 'text'
      });
    }
  }

  return codeBlocks;
}

/**
 * Generate project structure from workflow outputs
 */
export function generateProjectStructure(workflow: WorkflowRun): ProjectStructure {
  const files: ProjectStructure = {};

  // Extract outputs by role
  const outputs: Record<string, string> = {};
  for (const step of workflow.steps) {
    if (step.status === 'completed' && step.output) {
      outputs[step.roleId] = step.output;
    }
  }

  // Backend files (from backend agent output)
  if (outputs.backend) {
    const pythonBlocks = extractCode(outputs.backend, 'python');
    const tsBlocks = extractCode(outputs.backend, 'typescript');
    const jsBlocks = extractCode(outputs.backend, 'javascript');

    if (pythonBlocks.length > 0) {
      files['backend/main.py'] = pythonBlocks[0].code;
      pythonBlocks.slice(1).forEach((block, idx) => {
        files[`backend/routes_${idx + 1}.py`] = block.code;
      });
    }

    if (tsBlocks.length > 0) {
      files['backend/index.ts'] = tsBlocks[0].code;
    }

    if (jsBlocks.length > 0) {
      files['backend/index.js'] = jsBlocks[0].code;
    }
  }

  // Frontend files (from frontend agent output)
  if (outputs.frontend) {
    const tsxBlocks = extractCode(outputs.frontend, 'tsx');
    const cssBlocks = extractCode(outputs.frontend, 'css');

    if (tsxBlocks.length > 0) {
      files['src/App.tsx'] = tsxBlocks[0].code;
      tsxBlocks.slice(1).forEach((block, idx) => {
        files[`src/components/Component${idx + 1}.tsx`] = block.code;
      });
    }

    if (cssBlocks.length > 0) {
      files['src/App.css'] = cssBlocks[0].code;
    }
  }

  // Database files (from database agent output)
  if (outputs.database) {
    const sqlBlocks = extractCode(outputs.database, 'sql');
    if (sqlBlocks.length > 0) {
      files['db/schema.sql'] = sqlBlocks[0].code;
      sqlBlocks.slice(1).forEach((block, idx) => {
        files[`db/migration_${idx + 1}.sql`] = block.code;
      });
    }
  }

  // Test files (from QA agent output)
  if (outputs.qa) {
    const testBlocks = extractCode(outputs.qa, 'python');
    const jsTestBlocks = extractCode(outputs.qa, 'typescript');

    if (testBlocks.length > 0) {
      files['tests/test_main.py'] = testBlocks[0].code;
    }

    if (jsTestBlocks.length > 0) {
      files['tests/test.spec.ts'] = jsTestBlocks[0].code;
    }
  }

  // DevOps files (from devops agent output)
  if (outputs.devops) {
    const dockerBlocks = extractCode(outputs.devops, 'dockerfile');
    const yamlBlocks = extractCode(outputs.devops, 'yaml');

    if (dockerBlocks.length > 0) {
      files['Dockerfile'] = dockerBlocks[0].code;
    }

    if (yamlBlocks.length > 0) {
      files['docker-compose.yml'] = yamlBlocks[0].code;
    }
  }

  // Architecture docs (from architect output)
  if (outputs.architect) {
    files['docs/ARCHITECTURE.md'] = outputs.architect;
  }

  // Tech docs (from tech_writer output)
  if (outputs.tech_writer) {
    files['docs/README.md'] = outputs.tech_writer;
  }

  return files;
}

/**
 * Create main README from workflow summary
 */
export function createREADME(workflow: WorkflowRun): string {
  const pmOutput = workflow.steps.find((s) => s.roleId === 'pm')?.output || '';
  const archOutput = workflow.steps.find((s) => s.roleId === 'architect')?.output || '';

  return `# ${workflow.featureRequest}

> Auto-generated project from Digital Twin MVP (Workflow ID: ${workflow.id})

## Overview

${pmOutput.substring(0, 500)}

## Architecture

${archOutput.substring(0, 500)}

## Getting Started

### Prerequisites
- Node.js 18+
- Python 3.9+ (if using Python backend)
- PostgreSQL or SQLite

### Installation

\`\`\`bash
# Install dependencies
npm install

# Set up database
npm run db:migrate

# Start development server
npm run dev
\`\`\`

### Running Tests

\`\`\`bash
npm run test
\`\`\`

### Building for Production

\`\`\`bash
npm run build
\`\`\`

## Project Structure

- \`/src\` - Frontend source code
- \`/backend\` - Backend API implementation
- \`/db\` - Database schemas and migrations
- \`/tests\` - Test files
- \`/docs\` - Documentation

## Generated By

- **Digital Twin MVP**: https://github.com/DSamuelHodge/agents
- **Generation Date**: ${workflow.createdAt}
- **Workflow ID**: ${workflow.id}

## Next Steps

1. Review generated code in this PR
2. Run tests to validate generated code quality
3. Deploy to staging environment
4. Conduct integration testing
5. Merge to production when ready

---

*This project was generated by a team of AI agents. Please review and test thoroughly before deploying.*`;
}

/**
 * Validate generated code (basic checks)
 */
export function validateProjectStructure(files: ProjectStructure): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // Check for required files
  if (!Object.keys(files).some(p => p.includes('README'))) {
    errors.push('Missing README file');
  }

  // Check for code files
  const hasCode = Object.keys(files).some(
    p =>
      p.endsWith('.py') ||
      p.endsWith('.ts') ||
      p.endsWith('.tsx') ||
      p.endsWith('.js')
  );

  if (!hasCode) {
    errors.push('No source code files generated');
  }

  // Check file syntax (basic)
  for (const [path, content] of Object.entries(files)) {
    if (path.endsWith('.json')) {
      try {
        JSON.parse(content);
      } catch {
        errors.push(`Invalid JSON in ${path}`);
      }
    }

    // Check for incomplete code blocks
    if (content.includes('// TODO:')) {
      errors.push(`${path} contains TODO comments`);
    }
  }

  return {
    valid: errors.length === 0,
    errors
  };
}
